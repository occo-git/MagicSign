package com.softigress.magicsigns.Game.Signs;

import android.animation.ObjectAnimator;
import android.graphics.Canvas;

import com.softigress.magicsigns.Game.Cells.Membrane.IMembraneListener;
import com.softigress.magicsigns.Game.Cells.Membrane.Membrane;
import com.softigress.magicsigns.Game.Dna.ProgressDna.IProgressDnaListener;
import com.softigress.magicsigns.Game.Dna.ProgressDna.ProgressDna;
import com.softigress.magicsigns.UI.FinishedResult.GrpFinishedResult;
import com.softigress.magicsigns.UI._base.Controls.Energy.EnergyCollection;
import com.softigress.magicsigns.UI._base.Controls.Energy.EnergyType;
import com.softigress.magicsigns.UI._base.Controls.Energy.IDrawingEnergyListener;
import com.softigress.magicsigns.Game.Puncher.DrawingPuncher;
import com.softigress.magicsigns.Game.Puncher.IDrawingPuncherListener;
import com.softigress.magicsigns.Game.Puncher.RaySign;
import com.softigress.magicsigns.Game.Signs.SSequence.ISSequenceListener;
import com.softigress.magicsigns.Game.Signs.SSequence.SSequence;
import com.softigress.magicsigns.Game.Signs.SSequence.SStatistics.ISStatisticsListener;
import com.softigress.magicsigns.Game.Signs.SSequence.SStatistics.SStatistics;
import com.softigress.magicsigns.Game.Signs.SignHelper.SignHelper;
import com.softigress.magicsigns.Game.Signs._base.DrawingSignCell;
import com.softigress.magicsigns.Game.Signs._base.IDrawingSignListener;
import com.softigress.magicsigns.Game.Signs._base.SignPunchType;
import com.softigress.magicsigns.R;
import com.softigress.magicsigns.UI._base.Controls.Achievements.AchievementCollection;
import com.softigress.magicsigns.UI._base.Controls.Achievements.AchievementType;
import com.softigress.magicsigns.UI._base.Controls.Bonuses.BonusCollection;
import com.softigress.magicsigns.UI._base.Controls.Bonuses.BonusType;
import com.softigress.magicsigns.UI._base.Controls._base.Counters.CtrlCounterInv;
import com.softigress.magicsigns.UI._base.Controls._base.Counters.CtrlStarsCounter;
import com.softigress.magicsigns.UI._base.Controls.Drop.DropMotionType;
import com.softigress.magicsigns.UI._base.Controls.Drop.FunnyDrop;
import com.softigress.magicsigns.UI._base.Controls.Lightning.LightningCollection;
import com.softigress.magicsigns.UI._base.Controls._base.Texts.DrawingText;
import com.softigress.magicsigns.UI._base.Effects.Explode.DrawingExplode;
import com.softigress.magicsigns._Base._Drawing.DrawingGroup;
import com.softigress.magicsigns._Base._Drawing._base.Alignment.DrawingHAlign;
import com.softigress.magicsigns._Base._Drawing._base.Alignment.DrawingVAlign;
import com.softigress.magicsigns._Base._Drawing._interfaces.IDownUpListener;
import com.softigress.magicsigns._Base._Drawing._interfaces.ITouchable;
import com.softigress.magicsigns._Base._Drawing._interfaces.ITouchableListener;
import com.softigress.magicsigns._system.FireBase.DataBase.UserScoreInfo;
import com.softigress.magicsigns._system.Settings.CurrentSettings;
import com.softigress.magicsigns._system.Settings.Infos.SignInfo;
import com.softigress.magicsigns._system.Settings.Infos.SignInfos;
import com.softigress.magicsigns._system.Utils.PaintUtils;
import com.softigress.magicsigns._system.Utils.TaskUtils;
import com.softigress.magicsigns._system.Utils.TextUtils;
import com.softigress.magicsigns._system.Utils.Utils;

public class GrpSigns extends DrawingGroup {

    private static final long showDuration = 2000;
    private static final long hideDuration = 1500;

    private final SignHelper signHelper;
    //private final MainCell mainCell;
    private final Membrane membrane;
    private final SSequence sSequence;
    private final EnergyCollection energies;
    private final BonusCollection bonuses = new BonusCollection();
    private final AchievementCollection achievements = new AchievementCollection();
    private final LightningCollection lightnings = new LightningCollection();
    private final CtrlStarsCounter ctrlStarsCount;
    private final CtrlCounterInv ctrlInvCount;
    private final DrawingExplode explode;
    public FunnyDrop drop;
    private final DrawingPuncher puncher;
    private final ProgressDna progressDna;
    private int punchedSignsSequentially; // подсчет количества сбитых подряд (обнуляем, если не сбит)

    public final SStatistics sStatistics;
    private int previousRecord = 0;
    //private final DrawingText txtRecordBreakScore;
    private final DrawingText txtRecordBreakComment;

    private boolean isStarted = false;
    public  boolean isCheckCollision = true;

    //private DrawingFrameRate frameRate;

    public GrpSigns() {
        super();

        signHelper = new SignHelper();
        addDrawing(signHelper);
        addRepeater(1000, new Runnable() { @Override public void run() { signHelp(); } });

        membrane = new Membrane();
        membrane.setListener(new IMembraneListener() {
            @Override
            public void handleOnMultiplierSet(int multiplier) {
                if (drop != null)
                    drop.setMultiplier(multiplier);
            }
            @Override
            public void handleOnMultiplierTouch() {
                if (listener != null)
                    listener.handleOnMultiplierTouch();
            }
            @Override
            public void handleOnFinish() {
                //game over
                if (listener != null)
                    listener.handleOnGameOver();
                //if (signHelper != null)
                    signHelper.hide();
                if (drop != null) {
                    drop.setMotion(DropMotionType.PUNCHED);
                    Utils.playSound(R.raw.punch03);
                    Utils.playSound(R.raw.virus02);
                    if (getScore() > 0)
                        drop.setMessagePoint(.5f, .90f);
                    else
                        drop.setMessagePoint(.5f, .83f);
                    drop.showMessage(5000, FunnyDrop.MES_PUNCHED);
                }
            }
        });
        addDrawingGroup(membrane);

        progressDna = new ProgressDna(.175f); // isHorizontal
        progressDna.startWaves(1.5f);
        progressDna.setPoint(ProgressDna.dnaFx, ProgressDna.dnaFy);
        progressDna.setListener(new IProgressDnaListener() {
            @Override
            public void handleFinished(int score) {
                if (ctrlStarsCount != null) {
                    ctrlStarsCount.countUp(score);
                    if (ctrlInvCount != null)
                        ctrlInvCount.addInventory();
                    if (drop != null) {
                        drop.setMotion(DropMotionType.JOKE);
                        drop.showMessage(1000, FunnyDrop.MES_JOKE);
                    }
                }
            }
        });
        progressDna.setListener(new ITouchableListener() {
            @Override
            public void handelOnTouch(ITouchable item) {
                if (listener != null)
                    listener.handleOnDnaTouch();
            }
            @Override
            public void handelOnTouchUp(ITouchable item) {  }
        });
        addDrawingTouchable(progressDna);

        ctrlStarsCount = new CtrlStarsCounter();
        addDrawing(ctrlStarsCount);

        ctrlInvCount = new CtrlCounterInv();
        ctrlInvCount.setListener(new ITouchableListener() {
            @Override
            public void handelOnTouch(ITouchable item) {
                if (!ctrlInvCount.canUseInventory())
                    if (listener != null)
                        listener.handleOnDnaBombTouch();
            }
            @Override
            public void handelOnTouchUp(ITouchable item) {
                //useInventory();
            }
        });
        ctrlInvCount.setListener(new IDownUpListener() {
            @Override public void handelOnDownUp(ITouchable item) { useInventory(); }
        });
        addDrawingTouchable(ctrlInvCount);

        explode = new DrawingExplode(.5f, .5f, .1f, 3f, 255, 500, Utils.getBitmap(R.string.bmp_spot_orange));
        addDrawing(explode);

        //region record break
        //txtRecordBreakScore = new DrawingText(DrawingHAlign.CENTER, TextUtils.controls_game_record_break_score);
        //txtRecordBreakScore.setVerticalAlign(DrawingVAlign.BOTTOM);
        //txtRecordBreakScore.setTextBack(8f, 64, 255, 255, 255);
        //txtRecordBreakScore.setAlpha(0);
        //txtRecordBreakScore.setPoint(.5f, .33f);
        //addDrawing(txtRecordBreakScore);

        txtRecordBreakComment = new DrawingText(DrawingHAlign.CENTER, TextUtils.controls_game_record_break_comment);
        txtRecordBreakComment.setVerticalAlign(DrawingVAlign.TOP);
        txtRecordBreakComment.setText(R.string.game_record_break);
        txtRecordBreakComment.setTextBack(4f, 32, 0, 0, 0);
        txtRecordBreakComment.isPaintRect = true;
        txtRecordBreakComment.setAlpha(0);
        txtRecordBreakComment.setPoint(.5f, .38f);
        addDrawing(txtRecordBreakComment);
        //endregion

        sStatistics = new SStatistics();
        sStatistics.setListener(new ISStatisticsListener() {
            @Override
            public void handleOnAchievement(AchievementType achievementType) {
                achievements.addAchievement(achievementType);
            }
        });

        sSequence = new SSequence();
        sSequence.setListener(new IDrawingSignListener() {
            @Override
            public void onShowHelper(SignInfo info) {
                //if (signHelper != null)
                    //signHelper.showSign(info);
            }
            @Override
            public void onPunched(DrawingSignCell sign, SignPunchType punchType) {
                SignInfo si = sign.getCurrentSignInfo();
                if (si != null) {
                    //if (sStatistics != null)
                        sStatistics.upSignInfo(si, sign.isGrouped()); // собираем данные об уничтоженных signs
                    int score = SignInfos.getScoreBySignInfo(si.strength);
                    //if (ctrlStarsCount != null) {
                        // если побит предыдущий рекорд отображаем сообщение
                        int currentScore = ctrlStarsCount.getCount() + score;
                        if (previousRecord > 0 && currentScore > previousRecord) {
                            showRecordBreakMessage(currentScore);
                            if (drop != null) {
                                drop.setMotion(DropMotionType.HAPPY);
                                drop.showMessage(1000, FunnyDrop.MES_HAPPY);
                            }
                        }
                        // добавим очки
                        ctrlStarsCount.countUp(score);
                        progressDna.nextPodOn();
                        // если collapsed Sign был уничтожен вручную (не бомбой и не молнией), начисляем бонус за угадывание знака
                        if (punchType == SignPunchType.Simple && sign.isCollapsed())
                            addBonus(BonusType.GUESS, SignInfos.getBonusBySignInfo(si.strength), .68f, .28f);
                        // если Sign был уничтожен молнией, начиляем бонус
                        if (punchType == SignPunchType.Lightning)
                            addBonus(BonusType.LIGHTNING, CurrentSettings.bonusLightning, sign.getFx(), sign.getFy());
                    //}
                    // помощь
                    if (signHelper.getSignInfoId() == si.id)
                        signHelper.hideSign();
                    // молния
                    if (sign.isLightning()) { // && lightnings != null) {
                        double angel = sign.getRotateLightningAngel();
                        lightnings.addLightning(CurrentSettings.signLightningDuration, CurrentSettings.signLightningFd,
                                PaintUtils.strokeWidth2, PaintUtils.strokeWidth * 3f,
                                sign.getFx(), sign.getFy(), angel);
                    }
                }
            }
            @Override
            public void onMissed(SignInfo info) {
                // сбросим число сбитых подряд
                progressDna.reset();
                if (signHelper.getSignInfoId() == info.id)
                    signHelper.hideSign();
                if (drop != null) {
                    drop.setMotion(DropMotionType.SURPRISE);
                    drop.showMessage(1500, FunnyDrop.MES_SURPRISE);
                }
            }
            @Override
            public void onBreakCell(float fx, float fy) {
                if (energies != null)
                    energies.startEnergy(fx, fy, GetEnergyType());
            }
        });
        sSequence.setListener(new ISSequenceListener() {
            @Override
            public void handleOnFinish(boolean isWin) {
                if (listener != null && isWin) {
                    listener.handleOnWin();
                    if (drop != null) {
                        drop.setMotion(DropMotionType.WIN);
                        drop.setMessagePoint(.5f, .90f);
                        drop.showMessage(5000, GrpFinishedResult.getOrdenMessage());
                    }
                }
                //if (signHelper != null)
                    signHelper.hide();
            }
        });

        energies = new EnergyCollection();
        energies.setListener(new IDrawingEnergyListener() {
            @Override
            public void onCatched(EnergyType type) {
                if (type == EnergyType.SIMPLE) {
                    //if (membrane != null)
                        membrane.chargeCurrentCover(1);
                } else if (type == EnergyType.DNA) {
                    // получаем текущее количество ready dna pods
                    int readyPodsCount = progressDna.nextPodReady();
                    // сохраняем в БД количество готовых элементов DNA
                    if (CurrentSettings.isSaveDnas)
                        Utils.dataBaseManager.updateReadyDnaPods(readyPodsCount);
                } else if (type == EnergyType.EXPLODE) {
                    //if (ctrlInvCount != null)
                        ctrlInvCount.addInventory();
                }
            }
        });

        puncher = new DrawingPuncher();
        puncher.setListener(new IDrawingPuncherListener() {
            @Override
            public void handleOnRayPunch(RaySign raySign) {
                int punched = raySign == null ? 0 : sSequence.getPunched(raySign);
                checkBonusPunched(punched); // Проверка на получение бонуса
            }
        });

        /*if (CurrentSettings.isTestMode) {
            BtnBase b1 = new BtnBase(.4f, .85f, .05f, R.string.bmp_btn_checked);
            b1.setListener(new IClickListener() {
                @Override
                public void handleOnClick(ITouchable item) {
                    membrane.chargeCurrentCover(5);
                }
            });
            addDrawingTouchable(b1);
            BtnBase b2 = new BtnBase(.6f, .85f, .05f, R.string.bmp_btn_unchecked);
            b2.setListener(new IClickListener() {
                @Override
                public void handleOnClick(ITouchable item) {
                    membrane.breakMembrane();
                }
            });
            addDrawingTouchable(b2);
        }*/

        //frameRate = new DrawingFrameRate("SIGNS", .02f, .05f);
    }

    private void signHelp() {
        if (signHelper.isAllowShowSign()) {
            //if (sSequence != null) {
                SignInfo signInfo = sSequence.getHelpSign();
                if (signInfo != null)
                    signHelper.showSign(signInfo);
            //}
        }
    }

    private IGrpSignsListener listener;
    public void setListener(IGrpSignsListener l) { listener = l; }

    //region Bonuses
    private void checkBonusPunched(Integer punched) {
        // бонус за сбитых одновременно (комбо)
        if (punched > 1)
            addBonus(BonusType.COMBO, punched, .32f, .20f);

        // бонус за сбитых подряд (сиквенс)
        int ps = punchedSignsSequentially;
        if (punched > 0)
            ps += punched;
        else
            ps = 0; // сбрасываем количество сбитых подряд
        if (ps > 2 && (ps == 5 || ps == 10 || ps == 15 || ps == 20 || ps == 30 || ps == 50))
                addBonus(BonusType.SEQUENCE, ps, .68f, .12f);

        punchedSignsSequentially = ps >= 50 ? 0 : ps;
    }

    private void checkBonusExplode(Integer exploded) {
        // бонус за > 4 взорванных одновременно
        if (exploded > 4)
            addBonus(BonusType.STRIKE, exploded, .32f, .36f);
    }

    private void addBonus(final BonusType type, final int count, final float fx, final float fy) {
        TaskUtils.postDelayed(CurrentSettings.bonusDelay, new Runnable() {
            @Override
            public void run() {
                int bonus = bonuses.addBonus(type, count, fx, fy);
                if (bonus > 0)
                    ctrlStarsCount.countUp(bonus); // добавим очки
            }
        });
    }
    //endregion

    //region Energies
    private EnergyType GetEnergyType() {
        // определим вероятность появления DnaEnergy
        float dnaVariability = (CurrentSettings.dnaMaxReadyPodsCount - progressDna.getReadyPodsCount()) / (float) sSequence.allWavesStepsCount;
        //float dnaVariability = 1f;

        if (Utils.getRandom() < dnaVariability) // вероятность DNA
            return EnergyType.DNA;
        else
            // вероятность Explode
            return Utils.getRandom() < CurrentSettings.probabilityEnergyExplode ? EnergyType.EXPLODE : EnergyType.SIMPLE;
    }
    //endregion

    //region Touch
    @Override
    public boolean onTouch(int x, int y) {
        super.onTouch(x, y);
        puncher.onTouch(x, y);
        sSequence.onTouch(x, y);
        energies.onTouch(x, y);
        return true;
    }

    @Override
    public boolean onTouchUp(int x, int y) {
        super.onTouchUp(x, y);
        if (puncher.onTouchUp(x, y))
            return true;
        sSequence.onTouchUp(x, y);
        energies.onTouchUp(x, y);
        return false;
    }

    @Override
    public void onMoveTo(int x, int y) {
        super.onMoveTo(x, y);
        puncher.onMoveTo(x, y);
        sSequence.onMoveTo(x, y);
        energies.onMoveTo(x, y);
    }
    //endregion

    public void setEnabled(boolean enabled) {
        // включаем/выключаем
        puncher.setEnabled(enabled); // puncher
        energies.isEnabled = enabled; // сбора энергии
        sStatistics.isEnabled = enabled; // сбора статистики
        bonuses.isEnabled = enabled; // сбора бонусов
        achievements.isEnabled = enabled; // сбора достижений
    }

    public void start() {
        isStarted = true;

        setEnabled(true);
        progressDna.reset();

        if (Utils.dataBaseManager.currentUserScoreInfo != null) {
            UserScoreInfo usi = Utils.dataBaseManager.currentUserScoreInfo;
            // запомним значение предыдущего рекорда
            previousRecord = usi.score;
            // установим количество заряженых элементов днк
            if (CurrentSettings.isSaveDnas)
                progressDna.setReadyPodsCount(usi.dnas);
        } else
            // установим количество заряженых элементов днк
            progressDna.setReadyPodsCount(0);
        progressDna.show();

        //txtRecordBreakScore.setAlpha(0);
        //txtRecordBreakScore.show();
        txtRecordBreakComment.setAlpha(0);
        txtRecordBreakComment.show();

        //if (Utils.UserSettings().isMusic()) Utils.MusicPlay(R.raw.test_music);

        // старт последовательности
        TaskUtils.postDelayed(showDuration, new Runnable() {
            @Override
            public void run() {
                //if (sSequence != null) {
                    sStatistics.init();
                    sSequence.start();
                //}
            }
        });
    }

    public int getScore() { return ctrlStarsCount != null ? ctrlStarsCount.getCount() : 0; }

    public int getFinishedWavesCount() { return sSequence.getFinishedWavesCount(); }

    private void showRecordBreakMessage(Integer score) {
        long duration = 2000;
        Utils.playSound(R.raw.record_break01);
        // обнулим значение, чтобы сообщение больше не показывалось
        previousRecord = 0;
        // отобразим сообщение о побитии предыдущего рекорда
        //txtRecordBreakScore.setText(score.toString());
        //ObjectAnimator.ofInt(txtRecordBreakScore, "Alpha", 0, 255, 255, 0).setDuration(duration).start();
        ObjectAnimator.ofInt(txtRecordBreakComment, "Alpha", 0, 255, 255, 0).setDuration(duration).start();
        TaskUtils.postDelayed(duration, new Runnable() {
            @Override
            public void run() {
                //txtRecordBreakScore.hide();
                txtRecordBreakComment.hide();
            }
        });
    }

    private void useInventory() {
        if (ctrlInvCount.canUseInventory()) {
            // взрыв
            Utils.playSound(R.raw.explode16);
            if (explode != null)
                explode.startAnim();
            // эмоция drop
            if (drop != null)
                drop.setMotion(DropMotionType.PRO);
            // инвентарь tap
            if (ctrlInvCount.canUseInventory())
                ctrlInvCount.startBackAnim(false);
            // уничтожение происходит через паузу
            //TaskUtils.postDelayed(CurrentSettings.explodeStartDelay, new Runnable() {
            //    @Override
            //    public void run() {
            if (ctrlInvCount.useInventory()) {
                //if (sSequence != null) {
                    int exploded = sSequence.explode();
                    checkBonusExplode(exploded);
                    if (drop != null) {
                        if (exploded == 0)
                            drop.showMessage(1000, FunnyDrop.MES_BOMB_0);
                        else if (exploded == 1)
                            drop.showMessage(1000, FunnyDrop.MES_BOMB_1);
                        else if (exploded == 2)
                            drop.showMessage(1000, FunnyDrop.MES_BOMB_2);
                        else if (exploded >= 3)
                            drop.showMessage(1000, FunnyDrop.MES_BOMB_3);
                    }
                //}
            }
            //    }
            //});
        }
    }

    //region show/hide
    @Override
    public void show() {
        super.show();
        if (membrane != null)
            membrane.show();
        if (ctrlStarsCount != null)
            ctrlStarsCount.show();
        if (ctrlInvCount != null)
            ctrlInvCount.show();
        if (sSequence != null)
            sSequence.show();
        //if (progressDna != null)
        //    progressDna.show();
    }
    @Override
    public long hide() {
        super.hide();
        if (sSequence != null)
            sSequence.finish();
        if (energies != null)
            energies.finish();
        if (membrane != null)
            membrane.hide();
        if (ctrlStarsCount != null)
            ctrlStarsCount.hide();
        if (ctrlInvCount != null)
            ctrlInvCount.hide();
        if (explode != null)
            explode.hide();
        if (progressDna != null)
            progressDna.hide();
        if (signHelper != null)
            signHelper.hide();
        if (sSequence != null)
            sSequence.hide();
        return hideDuration;
    }
    //endregion

    //region pause / resume game
    public void pause() {
        if (sSequence != null)
            sSequence.pause();
        if (energies != null)
            energies.pause();
    }
    public void resume() {
        if (sSequence != null)
            sSequence.resume();
        if (energies != null)
            energies.resume();
    }
    //endregion

    //region Draw
    public synchronized void calc() {
        super.calc();
        puncher.calc();
    }

    //Float vvv;
    public synchronized void drawFrame(Canvas c) {
        //if (frameRate != null)
        //    frameRate.start();

        super.drawFrame(c);

        if (sSequence != null && isStarted) {
            if (isCheckCollision)
                sSequence.checkCollision(membrane);
            sSequence.drawFrame(c);
        }
        if (energies != null)
            energies.drawFrame(c);
        //if (bonuses != null)
            bonuses.drawFrame(c);
        //if (achievements != null)
            achievements.drawFrame(c);
        //if (lightnings != null) {
            if (sSequence != null)
                sSequence.checkLightningHit(lightnings);
            lightnings.drawFrame(c);
        //}

        /*if (vvv != null)
            TextUtils.WriteSizedTextCenter(
                    c,
                    .5f * MetrixUtils.screen_metrix_width,
                    .85f * MetrixUtils.screen_metrix_height,
                    vvv.toString(),
                    TextUtils.getDefaultFontSize());*/

        //if (frameRate != null)
        //    frameRate.drawFrame(c);
    }

    public synchronized void drawPuncher(Canvas c) {
        puncher.drawFrame(c);
    }
    //endregion

    @Override
    public void recycle() {
        super.recycle();

        if (membrane != null)
            membrane.recycle();
        if (sSequence != null)
            sSequence.recycle();
        if (energies != null)
            energies.recycle();
        //if (bonuses != null)
            bonuses.recycle();
        //if (achievements != null)
            achievements.recycle();
        //if (lightnings != null)
            lightnings.recycle();
        if (puncher != null)
            puncher.recycle();
        //if (frameRate != null)
        //    frameRate.recycle();

        listener = null;
    }
}
